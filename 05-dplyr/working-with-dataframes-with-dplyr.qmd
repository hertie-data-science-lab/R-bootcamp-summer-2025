---
title: "Working with Dataframes with `dplyr`"
format: revealjs
---

## dplyr

dplyr is a R package for working with dataframes. It's used for subsetting and manipulating data and is one of the core packages in the Tidyverse, a collection of packages used by most people in the R community. ggplot is another Tidyverse package.

```{r}
library(tidyverse)
```

## World Population Data

::: {.columns}

::: {.column width="50%"}
- `country`: Abbreviated country name
- `period`: Five year period of data collection
- `age`: Age group
- `births`: Number of births*
:::

::: {.column width="50%"}
- `deaths`: Number of deaths*
- `py.men`: Number of person-years*
- `py.women`: Number of person-years*

\* (in thousands)
:::

:::

where person-year is a measure of the time contribution of each person during the period. For example, someone alive for two years during a five year period of data collection has two person-years.

Source: [Quantiative Social Science: An Introduction](https://press.princeton.edu/books/paperback/9780691175461/quantitative-social-science)

## Reading in a Dataframe

```{r}
pop <- read_csv("data/World.csv")

pop
```

## dplyr Basics

With dplyr verbs (functions)

1. the first argument is always a data frame.
2. the subsequent arguments typically describe which columns to operate on using the variable names (without quotes).
3. the output is always a new data frame.

The functions are combined with the pipe operator `|>` or `%>%`.

Source: [Data Transformation in R for Data Science](https://r4ds.hadley.nz/data-transform.html#dplyr-basics)

## dplyr Basics

![The first argument of dplyr functions is a dataframe. dplyr functions return a dataframe. This makes them easy to chain together.](images/data_verb_input_output.png)

Source: [Data Programming for the Social Sciences](https://ds4ps.org/dp4ss/)

## The Pipe

![dplyr functions can be chained together using the pipe operator (`|>` or `%>%`). The pipe operator passes the dataframe returned by a function into the next function.](images/chaining_data_verbs.png)

Source: [Data Programming for the Social Sciences](https://ds4ps.org/dp4ss/)

## `filter()`

`filter()` allows us to subset rows in a dataframe. For example, if we are only interested in population data for ages 25 to 29, we can do

```{r}
pop |>
  filter(age == "25-29")
```

## `filter()`

`filter()` can have subset rows multiple ways by separating the filters with a comma. These chunks of code do the same thing

::: {.columns}

::: {.column width="50%"}
```{r}
pop |>
  filter(age == "25-29") |>
  filter(period == "2005-2010")
```
:::

::: {.column width="50%"}
```{r}
pop |>
  filter(age == "25-29",
         period == "2005-2010")
```
:::

:::

## Exercise

Find the row(s) where births exceed deaths and there are more person-years for men than women.

## Solution

```{r}
pop |>
  filter(births > deaths) |>
  filter(py.men > py.women)
```

## `arrange()`

`arrange()` reorders rows based on the value of columns.

```{r}
pop |>
  arrange(desc(births))
```

## Exercise

Sort the rows where births exceed deaths and there are more person-years for men than women by deaths (descending).

## Solution

```{r}
pop |>
  filter(births > deaths) |>
  filter(py.men > py.women) |>
  arrange(desc(deaths))
```

## `distinct()`

`distinct()` returns unique rows in the dataframe. It optionally takes column names as arguments. If supplied with column names, it returns the unique rows of the columns.

```{r}
pop |>
  distinct(period)
```

## `count()`

`count()` is like `distinct()` with named columns, but includes a column (`n`) with the number of rows in the original dataframe per unique combination.

```{r}
pop |>
  count(period)
```

## Exercise

Count the number of rows in each time period where births exceed deaths and there are more person-years for men than women.

## Solution

```{r}
pop |>
  filter(births > deaths) |>
  filter(py.men > py.women) |>
  count(period)
```

## dplyr Row Exercises

Let's take a break to work through the exercises in [row-exercises.qmd](row-exercises.qmd).

## `select()`

`select()` subsets columns in a dataframe. For example

```{r}
pop |>
  select(period, age, births, deaths)
```

## `rename()`

`rename()` renames columns in a dataframe. For example

```{r}
pop |>
  select(period, age, births, deaths) |>
  rename(time_period = period, age_range = age)
```

## `relocate()`

`relocate()` changes the order of columns. By default, it moves the named columns to the front. For example

```{r}
pop |>
  select(period, age, births, deaths) |>
  relocate(age)
```

## `mutate()`

`mutate()` is used to create new columns. For example

```{r}
pop |>
  select(period, age, births, deaths) |>
  mutate(births_deaths_ratio = births / deaths)
```

## Exercise

Calculate the _crude birth rate_ (CBR) for each row, where

$$
CBR = \frac{\text{number of births}}{\text{number of person-years}}
$$

Source: [Quantiative Social Science: An Introduction](https://press.princeton.edu/books/paperback/9780691175461/quantitative-social-science)

## Solution

```{r}
pop |>
  mutate(CBR = births / (py.men + py.women))
```

## Exercise

What row has the highest crude birth rate?

## Solution

```{r}
pop |>
  mutate(CBR = births / (py.men + py.women)) |>
  arrange(desc(CBR))
```

## `summarise()`

`summarise()` is used to calculate summary statistics for a dataframe. For example, we can find the minimum, mean, and maximum number of births in the dataset with

```{r}
pop |>
  summarise(min_births = min(births),
            mean_births = mean(births),
            max_births = max(births))
```

## Exercise

Find the minimum, mean, and maximum number of births among rows with more than zero births.

## Solution

```{r}
pop |>
  filter(births > 0) |>
  summarise(min_births = min(births),
            mean_births = mean(births),
            max_births = max(births))
```

## Summarise Functions

Many functions can be used with summarise, including

::: {.columns}

::: {.column width="30%"}
- `min()`
- `max()`
- `mean()`
- `median()`
- `sum()`
:::

::: {.column width="70%"}
- `first()`: value of first row
- `last()`: value of last row
- `n()`: count of rows
- `n_distinct()`: number of distinct rows
:::

:::

## `group_by()`

`group_by()` tells R to perform operations on the distinct groups defined inside `group_by()` until `ungroup()` is used. For example

```{r}
pop |>
  filter(births > 0) |>
  group_by(period) |>
  summarise(min_births = min(births),
            mean_births = mean(births),
            max_births = max(births))
```

## Exercise

Calculate the crude birth rate for each period (1950-1955 and 2005-2010) across age groups by

1. Calculating the combined number of person-years for each age group for each period
2. Summing person-years and births by time period
3. Dividing births by person-years

## Solution

```{r}
pop |>
  mutate(person_years = py.men + py.women) |>
  group_by(period) |>
  summarise(births = sum(births),
            person_years = sum(person_years)) |>
  mutate(CBR = births / person_years)
```

## Exercise

Let's return to the penguin dataset. Calculate the minimum, mean, median, and maximum body mass of penguins by species and island. Include the number of penguins in each sample.

## Solution

```{r}
penguins |>
  group_by(species, island) |>
  summarise(
    min = min(body_mass),
    mean = mean(body_mass),
    median = median(body_mass),
    max = max(body_mass),
    n = n()
  )
```

## Solution (cont)

Some values are `NA` because `NA`s propagate in R. In other words, if any values in a group are `NA`, then functions like `min()`, `max()`, and `sum()` will return `NA` by default. We can disable this behavior by including `na.rm = TRUE` in the functions.

## Solution (cont)

```{r}
penguins |>
  group_by(species, island) |>
  summarise(
    min = min(body_mass, na.rm = TRUE),
    mean = mean(body_mass, na.rm = TRUE),
    median = median(body_mass, na.rm = TRUE),
    max = max(body_mass, na.rm = TRUE),
    n = n(),
    # this is an easy way to get the number of NA values in a group when using summarise()
    n_na = sum(is.na(body_mass))
  )
```