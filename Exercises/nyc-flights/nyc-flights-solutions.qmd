# NYC Flights in 2013

For these exercises, we will use the dataframe `flights` from the `nycflights13` package, which has one row per flight that departed from New York City in 2013 (336776 rows).

```{r}
library(tidyverse)

if (!("nycflights13" %in% installed.packages())) {
  install.packages("nycflights13")
}
library(nycflights13)
flights <- flights

flights
```

Exercises 1 through 4 come from (or were adapted from) [R for Data Science](https://r4ds.hadley.nz/data-transform.html#exercises). Hint: these exercises can be solved with `filter()`, `distinct()`, and `count()`.

1. Was there a flight on every day in 2013?

```{r}
flights |>
  distinct(day, month) %>%
  count()
```

2. Find all flights that arrived more than two hours late but didnâ€™t leave late.

```{r}
flights |>
  filter(dep_delay <= 0) |>
  filter(arr_delay >= 120)
```

3. Find all destinations that had at least one flight with a flight time of 10 hours or more.

```{r}
flights |>
  filter(air_time >= 600) |>
  distinct(dest)
```

4. Find all flights in the summer (June, July, August) that arrived on time.

```{r}
flights |>
  filter(month >= 6, month <= 8) |>
  filter(arr_delay <= 0)
```

The remainder of the exercises were written by Jackson Luckey and will also use `group_by()`, `summarise()`, and `mutate()`.

5. How many destinations does each airport in NYC serve?

```{r}
flights |>
  group_by(origin) |>
  summarise(n_destinations = n_distinct(dest))
```

6. How many flights departed each airport in 2013? Does this follow the same pattern as the number of destinations?

```{r}
flights |>
  group_by(origin) |>
  summarise(
    n_destinations = n_distinct(dest),
    n_flights = n()
  ) |>
  mutate(n_flights_per_destination = n_flights / n_destinations)
```

7. How about carriers?

```{r}
flights |>
  group_by(origin) |>
  summarise(
    n_destinations = n_distinct(dest),
    n_carriers = n_distinct(carrier),
    n_flights = n()
  ) |>
  mutate(
    n_flights_per_destination = n_flights / n_destinations,
    n_flights_per_carrier = n_flights / n_carriers
  )
```

For the rest of the exercises, imagine that you are an analyst at ann organization tasked with assessing the performance of New York City's three airports and the carriers operating out of them as part of an effort to reduce departure delays.

8. Create a new variable, `delayed_departure`, that is `TRUE` when a flight has a delayed departure. What proportion of flights have delayed departures?

```{r}
flights <- flights |>
  mutate(delayed_departure = dep_delay > 0)

flights |>
  count(delayed_departure) |>
  mutate(prop = n / sum(n))
```

Note: `dep_delay` is missing for ~2.5% of flights, which is the source of `NA`. Recall that `NA`s propagate in R. In other words, if any values in a group are `NA`, then functions like `min()`, `max()`, and `sum()` will return `NA` by default. We can disable this behavior by including `na.rm = TRUE` in the functions like `min(column, na.rm = TRUE)`. We'll ignore this for now and use `na.rm = TRUE` as needed.

9. Calculate the proportion of flights with delayed departures by origin airport and by carrier. You're producing two separate tables.

```{r}
flights |>
  group_by(origin) |>
  summarise(prop_delayed = mean(delayed_departure, na.rm  = TRUE)) |>
  arrange(desc(prop_delayed))
```

```{r}
flights |>
  group_by(carrier) |>
  summarise(prop_delayed = mean(delayed_departure, na.rm  = TRUE)) |>
  arrange(desc(prop_delayed))
```

You notice that the departure delay rate varies signficantly by origin, destination, and carrier. With just this information, however, it is hard to identify the route of the problem. NYC's three airports could have different departure delay rates through no fault of their own because the carriers operating out of them differ. Likewise, the departure delay rates of the carriers might differ because of differences between the airports they operate in. To address this, you decide to analyze the airports and carriers conjointly.

10. Create a new dataframe with one row per origin airport per carrier that counts the number of flights and the departure delay rate. I named it `origin_carrier`, but feel free to use a different name.

```{r}
origin_carrier <- flights |>
  group_by(origin, carrier) |>
  summarise(
    n_flights = n(),
    prop_delayed = mean(delayed_departure, na.rm  = TRUE)
  ) |>
  arrange(desc(prop_delayed))

origin_carrier
```

You want to compare the departure delay rate in `origin_carrier` to the airport departure delay rate and the carrier departure delay rate. While you'll learn another way to do this in the Intro to Data Science course (joins), this can be accomplished by combining `group_by()` and `mutate()`. When combined with `group_by()`, `mutate()` performs operations on groups rather than rows. In other words, it functions similarily to `summarise()` but does not reduce the number of rows. For example, we can add a column with the total number of flights per origin airport with

```{r}
origin_carrier |>
  group_by(origin) |>
  mutate(origin_flights = sum(n_flights))
```

A fundamental skill in data analysis is identifying the correct unit of analysis. In `flights`, each row is a flight departing from one of New York City's three airports. Therefore, `n_flights` in exercises 6 and 7 identifies the total number of flights that departed. Likewise, the `prop_delayed` calculations in exercises 9 and 10 use the number of flights that departed as the denominator. We want to calculate the airport and carrier departure delay rates the same way. In `origin_carrier`, each row is an airport-carrier pair. If we calculated it using `mean(prop_delayed)` on `origin_carrier` as is, we would be count origin-carrier pairs with tens of thousands of flights as equivalent to those with only a small number of flights. Compare

```{r}
origin_carrier |>
  group_by(origin) |>
  summarise(prop_delayed = mean(prop_delayed))
```

to

```{r}
flights |>
  group_by(origin) |>
  summarise(prop_delayed = mean(delayed_departure, na.rm = TRUE))
```

You can address this by either using `n_flights` as a weight (`sum(n_flights * prop_delayed) / sum(n_flights)`) or calculating the origin and airport departure delay rates before using `summarise()`.

11. Modify `origin_carrier` to include the airport departure delay rates and the carrier departure delay rates.

```{r}
# weighting
origin_carrier <- origin_carrier |>
  group_by(origin) |>
  mutate(origin_prop_delayed = sum(n_flights * prop_delayed) / sum(n_flights)) |>
  group_by(carrier) |>
  mutate(carrier_prop_delayed = sum(n_flights * prop_delayed) / sum(n_flights))
```

```{r}
# From scratch
origin_carrier <- flights |>
  group_by(origin) |>
  mutate(origin_prop_delayed = mean(delayed_departure, na.rm = TRUE)) |>
  group_by(carrier) |>
  mutate(carrier_prop_delayed = mean(delayed_departure, na.rm = TRUE)) |>
  # Need to include origin_prop_delayed and carrier_prop_delayed so they persist after summarise()
  group_by(origin, carrier, origin_prop_delayed, carrier_prop_delayed) |>
  summarise(
    n_flights = n(),
    prop_delayed = mean(delayed_departure, na.rm = TRUE)
  )
```

12. What origin-carrier pairs outperform the baseline for both the origin and carrier (i.e. have a lower delay rate than the origin and carrier delay rates)? What origin-carrier pairs underperform?

```{r}
origin_carrier |>
  filter(prop_delayed < origin_prop_delayed, prop_delayed < carrier_prop_delayed)
```

```{r}
origin_carrier |>
  filter(prop_delayed > origin_prop_delayed, prop_delayed > carrier_prop_delayed)
```